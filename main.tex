\documentclass{article}


\usepackage{biblatex} %Imports biblatex package
\addbibresource{refs.bib}

\usepackage{graphicx} % Required for inserting images

% Language setting
\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}

\title{coursework}
\author{xnpster}
\date{May 2023}



% Useful packages
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{diagbox}
\usepackage{caption}
\usepackage{blindtext}
\usepackage{titlesec}
\usepackage{indentfirst}
\addto\captionsrussian{\def\refname{Список используемой литературы}}
\usepackage{subfigure}
\usepackage[toc,page]{appendix}
\usepackage{float}
\usepackage{tikz}
\usepackage{minted}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{caption}
\usepackage{amssymb}



\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2
}

\begin{document}
\lstset{style=mystyle}


\begin{titlepage}
\begin{center}
    Московский государственный университет имени М. В. Ломоносова

    \includegraphics[width=50mm]{msu_title.png}

    \bigskip
    Факультет Вычислительной Математики и Кибернетики\\
    Кафедра Системного программирования\\[10mm]
    
    \textsf{\large\bfseries
        Курсовая работа\\
        "Разработка и реализация алгоритма подстановки выражений в последовательных программах с помощью графа потока управления"\\[20mm]
    }
    
    \begin{flushright}
        \parbox{0.5\textwidth}{
        	Выполнил:\\
        	студент 3 курса 327 группы \\
        	\emph{Кочармин Михаил Дмитриевич}\\[5mm]
            Научный руководитель:\\
        	\emph{профессор Крюков Виктор Алексеевич} \\
            Научный консультант:\\
        	\emph{Колганов Александр Сергеевич} \\
    }
    \end{flushright}
    \vspace{\fill}
    Москва, 2023
\end{center}
\end{titlepage}

\newpage
\tableofcontents
\newpage

\section{Введение}
Данная работа проводилась в рамках разработки программного обеспечения SAPFOR 
-- системы для автоматизации распараллеливания Фортран-программ. Целью данной работы
является добавление в SAPFOR реализаций алгоритмов подстановки выражений, анализа живых переменных и приватных переменных.

Система SAPFOR представляет собой набор проходов -- отдельных стадий выполнения, 
которые последовательно запускаются с целью сбора информации и/или преобразования текста входной программы.
Соответсвенно, в систему были добавлены три прохода с названиями \texttt{SUBST\_ANALYSIS\_IR}, \texttt{LIVE\_ANALYSIS\_IR} и \texttt{PRIVATE\_ANALYSIS\_IR}.

\section{Постановка задач}

\subsection{Подстановка выражений}
Подстановка выражений заключается в замене скалярных переменных в выражениях на другие, эквивалентные им, 
скаляры или выражения. При этом, стоит цель максимировать количество замен в каждой цепочке подстановок.
\\[3mm]
Пример:
\\

\noindent\begin{minipage}{.45\textwidth}
    \begin{lstlisting}[language=Fortran, caption=До подстановки,frame=shadowbox]{Name}
...
DO I = 1, N
  DO J = I, M
    P = J + I
    Q = J - I

    F = P / Q

    A(2*P, 3*Q) = F        
  ENDDO
ENDDO
...
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.45\textwidth}
    \begin{lstlisting}[language=Fortran, caption=После подстановки,frame=shadowbox]{Name}
...
DO I = 1, N
  DO J = I, M
    P = J + I
    Q = J - I

    F = (J + I) / (J - I)

    A(2*(J+I), 3*(J-I)) = 
           (J+I)/(J-I)      
  ENDDO
ENDDO
...
\end{lstlisting}
\end{minipage}


Одной из целей данного прохода является удаление зависимостей по данным, которые могут мешать распараллеливанию циклов.


\subsection{Анализ живых переменных}

Класс живых переменных определяется следующим образом \cite[643]{dragonbook}:

\newtheorem{defenition}{Определение}[subsection]

\begin{defenition}
    Предположим, что трехадресная команда i присваивает значение переменной x. Если команда j имеет x в качестве операнда и управление может
    перейти от i к j по пути, на котором нет промежуточных присваиваний x, то
    команда j \textbf{использует} значение x, вычисленное в команде i.
\end{defenition}

\begin{defenition}
    При этом, переменная x называется \textbf{живой}, или \textbf{активной} (\textbf{live}) в команде i.
\end{defenition}

Аналогично можно определить активность переменной не для конкретной инструкции, а для любой точки программы.

Задача прохода анализа живых переменных заключается в определении для каждого базового блока B множеств $IN_{live}[B]$ и $OUT_{live}[B]$ -- множеств живых переменных соответственно перед первой и после последней инструкции рассматриваемого блока.

Для практической пользы, вместе с каждой живой переменной нужно сохранить информацию о том, в каких инструкциях используется значение переменной из данной точки. При этом, в целях экономии ресурсов, 
хранить номера только тех инструкций, в которых значение будет использоваться в первый раз.

Более формально, если $I$ -- множество номеров всех инструкций, в который используется значение $x$ из точки $t$ перед первой (или после последней) инструкции базового блока, 
то нужно хранить только подмножество $I_0 \subseteq I$:\\

$I_0 = \{\ i \ |\ \forall i \in I\ $существует путь от $t$ до $i$, не содержащий $j$ $ \forall j \in I\ \}$.

\subsection{Анализ приватных переменных}

\begin{defenition}
    \textbf{Приватной} переменной x цикла c, называется скалярная переменная, значение которой можно локализовать в рамках одного витка цикла \cite{pri-var}. 
\end{defenition}

Это значит, что значение переменной $x$ после любого витка цикла не будет использоваться ни одним другим витком, оно не будет использоваться после цикла и не используется значение $x$, которое она имела до цикла. При этом практический интерес имеют только те приватные переменные, которые имеют в цикле хотя бы одно переопределение.

\begin{defenition}
Также выделяется класс \textbf{lastprivate-переменных} (или \textbf{приватных по выходу}) -- это приватные переменные, для которых нарушается вышеописанное требование для последнего витка, то есть значение такой переменной используется после цикла.
\end{defenition}

Задача прохода анализа приватных переменных -- для каждого цикла построить множества приватных и приватных по выходу переменных.

\subsection{Входные данные}

В качестве входных данных для прохода подстановки выражений предоставляются:
\begin{itemize}
    \item внутреннее представдение программы в виде графов базовых блоков функций (графы потока управления)
    \item результаты анализа достигающих определений для этого графа потока управления
    \item внутреннее представление программы в виде дерева операторов и выражений (часть библиотеки \textit{Sage++} \cite{sage})
\end{itemize}




Результаты анализа достигающих определений поставляются в виде словарей $IN_{RD}[B]$ и $OUT_{RD}[B]$ для каждого базового блока $B$.
Ключами данного словаря являются переменные, а значениями -- множества номеров инструкций, которые порождают определения, 
достижимые в точке соответственно до и после базового блока $B$.


В проходе анализа живых переменных используется только граф потока управления.

В проходе анализа приватных переменных -- 
граф потока управления, граф циклов программы, Sage++-дерево \cite{sage} и результаты анализа живых переменных.

\section{Решение}

\subsection{Подстановка выражений}
Алгоритм подстановки выражений работает отдельно с каждым базовым блоком. Для каждой инструкции $i = 1..m$ вычисляется словарь $available[i]$.
Ключами в нём являются переменные, а значениями -- выражения, которыми можно заменить данные переменные в точке сразу после этой инструкции.\\
Пример:\\


\begin{minipage}{.45\textwidth}
\begin{lstlisting}[frame=shadowbox]{Name}
    [1] P = I - J
    [2] Q = I + J
    [3] F = P / Q
    [4] REF P
    [5] REF Q
    [6] STORE A 2 F
  
\end{lstlisting}
\end{minipage}\hfill
\begin{minipage}{.43\textwidth}
    % \centering
    $available[1] = \{ P \rightarrow I - J \}$

    $available[2] = \{ $
        
        $\qquad P \rightarrow I - J, $
        
        $\qquad Q \rightarrow I + J$

    $\}$

    $available[3] = \{$
        
        $\qquad P \rightarrow I - J, $
        
        $\qquad Q \rightarrow I + J,$

        $\qquad F \rightarrow P\ /\ Q\ $

    $\}$


    $available[4, 5, 6] = available[3]$

\end{minipage}\\\\


Сначала, перед итерацией по инструкциям блока, по множеству $IN_{RD}$ строится базовый словарь $available[0]$. Потом для каждой операции с номером $i = 1..m$ по $available[i-1]$ строится $available[i]$ следующим образом:

\begin{enumerate}
    \item $available[i] = available[i-1]$
    \item Пусть инструкция $i$ создаёт новые определения $a_1 \rightarrow e_1, ..., a_k \rightarrow e_k$, и определяет переменные $b_1, ..., b_r$ выражениями, которые невозможно скопировать в другое место (например, если выражение сожержит вызов функции)
    \item $\forall j$ если в $available[i]$ есть запись $a_j \rightarrow expr_j$ (или $b_j \rightarrow expr_j$), то во всех хранимых в $available[i]$ выражениях делается замена $b_j$ (или $a_j$) на $expr_j$
    \item $\forall j$ из $available[i]$ удалются все записи c ключём $a_j$ (или $b_j$) или те, которые содержат $a_j$ (или $b_j$) в выражении-значении 
    \item $\forall j$ в $available[i]$ добавляется запись $a_i \rightarrow e_i$
\end{enumerate}

После построения очередного множества $available[i-1]$ можно выполнить подстановку переменных в подвыражении, соответствующее инструкции с номером $i$. Необходимо заменить в этом подвыражении все переменные, которые есть в $available[i-1]$, на соответствующие выражения.
Так как после выполненых замен в этом подвыражении могут появиться другие неподставленные переменные, подстановку стоит осуществлять до тех пор, пока доступные замены не закончатся.

\subsection{Анализ живых переменных}

Сначала рассмотрим задачу для графа отдельной функции, поскольку именно в таком виде реализовано внутреннее представление.

Введём для базового блока два множества $def_B$ и $use_B$ так же, как и в \cite[733]{dragonbook}:

\begin{itemize}
    \item $def_B$ — множество переменных, определенных (т.е. получающих значения) в блоке $B$ до любых их использований в этом блоке;
    \item $use_B$ — множество переменных, значения которых могут использоваться
    в блоке $B$ до любых определений этих переменных.
\end{itemize}

Построив для каждого базового блока $B$ множества $def_B$ и $use_B$ можно записать соотношения для $IN_{live}[B]$ и $OUT_{live}[B]$ \cite[734]{dragonbook}:

\begin{equation*}
    IN_{live}[B] = use_B \cup  ( OUT_{live}[B] - def_B )
\end{equation*}

\begin{equation*}
    OUT_{live}[B] = \bigcup_{S\text{-- преемник}\ B} IN_{live}[S]
\end{equation*}

С граничным условием

\begin{equation*}
    OUT_{live}[\text{Выход}] = \varnothing
\end{equation*}


Существует итеративный алгоритм, который просматривает все базовые блоки и обновляет множества $IN_{live}[B]$,
$OUT_{live}[B]$ до тех пор, пока хотя бы в один базовый блок были внесены изменения \cite[735]{dragonbook}.


Было принято решение оптимизировать этот алгоритм:


Шаг 0. Положить 

\begin{equation*}
    \forall B:\ IN_{live}[B],\ OUT_{live}[B] = \varnothing.
\end{equation*}


Шаг 1. Игнорируя в графе базовых блоков обратные дуги, привести его к напраленному дереву. 
После этого перевести это дерево в массив базовых блоков $A$,
для которого выполнено соотношение: 
\begin{equation*}
    \forall i, j,\  i < j,\ \text{в построенном дереве нет пути из } A[i] \text{ в } A[j].
\end{equation*}

Шаг 2. Итерация по массиву $A[i]$ с его начала до конца (то есть в направлении от листьев к корню).
На каждой итерации сначала обновляются мнжества $IN_{live}[B]$ и $OUT_{live}[B]$.
Потом, $\forall j :$ до удаления существувала обратная дуга $A[j] \rightarrow A[i]$:

\begin{enumerate}
    
    \item Заного вычислить $IN_{live}[A[j]]$, $OUT_{live}[A[j]]$ уже рассматривая обратные дуги (то есть информация из блока $A[i]$ должна распространиться в блок $A[j]$).
    
    \item Если были внесены изменения в $IN_{live}[A[j]]$, то продолжить итерацию с элемента $A[j]$, то есть передвинуть указатель назад: $i := j$.

    \item Иначе продолжить просмотр обратных дуг.
    
    \item Если все обратные дуги просмотрены и перехода назад не произошло (или если обратных дуг, заканчивающихся в $A[i]$ нет), то продолжить итерацию: $i = i + 1$.

\end{enumerate}

Данный алгоритм тоже будет всегда сходиться, так как размеры множеств $IN_{live}$ ограничены и не убывают.


Ожидается, что в худшем случае этот алгоритм будет использовать работать намного быстрее.

Теперь следует учесть межпроцедурную часть анализа.
На этой стадии рассматриваются глобальные живые переменные после вызовов функции. Чтобы распространить информацию о них внутрь вызова, следует просто запустить
описанный выше алгоритм ещё раз, но только с соответствующим, вообще говоря, непустым, граничным условием.



\subsection{Анализ приватных переменных}

Имея результаты анализа живых переменных, найти для цикла $L$ множество приватных переменных $PRI(L)$ можно построив вспомогательное множество
$USE(L)$, определяемое следующим образом: переменная $x$ входит в $USE(L)$ тогда и только тогда, когда существует инструкция, которая может использовать значение переменной $x$ с какого-то из предыдущих витков цикла $L$ или значение, которое имело $x$ при входе в  этот цикл.

Очевидно, что $USE(L)$ совпадает с множеством всех переменных, которые имеют хотя бы одно достигающее определение на входе в первый базовый блок рассматриваемого цикла.

Введём множество $PRI^+(L)$:
\begin{equation*}
PRI^+(L) = DEF(L) - USE(L)
\end{equation*}

Где $DEF(L)$ -- множество всех переменных, которые могут переопределяться в цикле $L$.

Множество $PRI^+(L)$ является объединением множеств приватных и приватных по выходу переменных.

Таким образом, множесто приватных по выходу переменных
\begin{equation*}
PRI_{last}(L) = \{\ x\ |\ x \in PRI^+(L): x\ \text{жива на выходе из цикла}\ L\}
\end{equation*}
и
\begin{equation*}
    PRI(L) = PRI^+(L) - PRI_{last}(L).
\end{equation*}

\section{Возникшие проблемы}
\subsection*{Подстановка выражений и массивы}
    Поскольку достигающие определения строятся только для скаляров, при подстановке нет возможности использовать выражения, содержащие массивы, из других базовых блоков.

\subsection*{Циклы в графе вызова процедур}
    Первая проблема связана с циклами в графе вызова процедур. Для построения множества $def_B$ и $use_B$ нужно уже иметь результат прохода анализа живых переменных для каждой вызываемой функции. В текущей реализации обработка программ с циклами в графе вызова процедур не реализовано, 
    поэтому предполагается, что этот граф является деревом, и анализ проходит функции в направлении от листьев к корню.

\subsection*{Разрастание занятой памяти}
    При анализе больших проектов с большим количеством глобальных переменных, для сохранения результатов прохода жиывх переменных требуется слишком много памяти. Чтобы это исправить, пришлось изменить структуру данных, пожертвовав скоростью работы этого прохода.

\section{Результаты}
    В результате проведённой работы вышеописанные алгоритмы были успешно реализованы и интегрированы в систему SAPFOR.
    Добавленный код был тщательно протестирован на многочисленных проектах, в том числе на пакете NAS Parallel Benchmarks\cite{npb}:
\\

\begin{table}[h!]
    \centering
\begin{tabular}{ | c || p{2.5cm} | p{3.5cm} | p{2.5cm} |  }
 \hline
 Тест& количество подстановок & количество записей о живых переменных* &количество приватных переменных\\
 \hline
 BT & 2486 & 72411 & 348 \\
 \hline
CG & 82 & 4428 & 54 \\
\hline
EP & 33 & 1282 & 20 \\
\hline
FT & 228 & 3519 & 98 \\
\hline
LU & 3045 & 60864 & 406 \\
\hline
MG & 304 & 7504 & 71 \\
\hline
SP & 2269 & 117580 & 562 \\
 \hline
\end{tabular}
\caption*{\textit{* считается сумма размеров множеств IN и OUT всех базовых блоков }}
\end{table}


\printbibliography %Prints bibliography


\end{document}
